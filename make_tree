#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<malloc.h>

typedef struct Xaffman_node{
	char data;
	struct Xaffman_node* left;
	struct Xaffman_node* right;
	struct Xaffman_node* next;
	int kol;
}Xnode;

Xnode* derevo[256] = {NULL};
int count = 0;

void create(){
	for (int i = 0; i < 256; i++){
		derevo[i] = (Xnode*)malloc(sizeof(Xnode));
		derevo[i]->data = i;
		derevo[i]->left = NULL;
		derevo[i]->right = NULL;
		derevo[i]->next = NULL;
		derevo[i]->kol = 0;
	}
}

void initialization(char x){
	if (!derevo[x]->kol)
		count++;
	derevo[x]->kol++;
}

void swap(Xnode** a, Xnode** b){
	Xnode* t = *a;
	*a = *b;
	*b = t;
}

void sort(){
	for (int i = 0; i < 255; i++)
 		for (int j = 254; j >= i; j--)
 			if (derevo[j]->kol > derevo[j+1]->kol)
 				swap(&derevo[j], &derevo[j+1]);
}

Xnode* make_tree(int N){
	int k = N;
	for (int i = 256 - N; i < 255; i++)
		derevo[i]->next = derevo[i + 1];
	Xnode* first = derevo[256 - N];
	while(k - 1){
		Xnode* p = (Xnode*)malloc(sizeof(Xnode));
		p->right = first;
		p->left = first->next;
		p->kol = p->right->kol + p->left->kol;
		Xnode* t = p->left;
		while (t->next && t->next->kol < p->kol)
			t = t->next;
		p->next = t->next;
		t->next = p;
		first = first->next->next;
		k--;
	}
	return first;
}


void printp(Xnode* t) {
	if (!t) return;
	printf("%c %d\n", t->data, t->kol);
	printp(t->left);
	printp(t->right);
}


int main(){
	create();
	int N;
	scanf("%d\n", &N);
	for (int i = 0; i<N; i++){
		char c;
		scanf("%c", &c);
		initialization(c);
	}
	sort();
	Xnode* root = make_tree(count);
	printp(root);
	return 0;
}
